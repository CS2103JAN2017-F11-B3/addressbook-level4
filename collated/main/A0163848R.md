# A0163848R
###### /java/seedu/task/logic/Logic.java
``` java
    /**
     * Retrieves the current YTomorrow state.
     */
    ReadOnlyTaskManager getYTomorrow();

    /**
     * Overwrites the current YTomorrow.
     * @param YTomorrow to overwrite with
     */
    void setYTomorrow(ReadOnlyTaskManager set);

    /**
     * Adds entries to the current YTomorrow.
     * @param YTomorrow to add entries from
     */
    void importYTomorrow(ReadOnlyTaskManager add);
```
###### /java/seedu/task/logic/LogicManager.java
``` java
    @Override
    public ReadOnlyTaskManager getYTomorrow() {
        return model.getTaskManager();
    }

    @Override
    public void setYTomorrow(ReadOnlyTaskManager set) {
        model.resetData(set);
    }

    @Override
    public void importYTomorrow(ReadOnlyTaskManager add) {
        model.mergeYTomorrow(add);
    }
```
###### /java/seedu/task/logic/parser/RedoCommandParser.java
``` java
/**
 * Parses input arguments and creates a new DeleteCommand object
 */
public class RedoCommandParser {

    /**
     * Parses the given {@code String} of arguments in the context of the RedoCommand
     * and returns an RedoCommand object for execution.
     */
    public Command parse(String args) {
        try {
            return new RedoCommand();
        } catch (NoSuchElementException nsee) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
        }
    }

}
```
###### /java/seedu/task/logic/parser/AddCommandParser.java
``` java
    /**
     * Parses the given {@code String} of arguments in the context of the AddCommand
     * and returns an AddCommand object for execution.
     */
    public Command parse(String args) {
        final Matcher matcher = KEYWORDS_ARGS_FORMAT.matcher(args.trim());
        if (!matcher.matches()) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
        }

        // keywords delimited by whitespace
        final String[] keywords = matcher.group("keywords").split("\\s+");
        final List<String> keywordList = Arrays.asList(keywords);
        try {
            return new AddCommand(keywordList);
        } catch (IllegalValueException e) {
            return new IncorrectCommand(
                    e.getMessage() + String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
        }
    }
```
###### /java/seedu/task/logic/parser/ClearCommandParser.java
``` java
/**
 * Parses input arguments and creates a new FindCommand object
 */
public class ClearCommandParser {

    /**
     * Parses the given {@code String} of arguments in the context of the ClearCommand
     * and returns a ClearCommand object for execution.
     */
    public Command parse(String args) {
        final Matcher matcher = KEYWORDS_ARGS_FORMAT.matcher(args.trim());
        if (!matcher.matches()) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, ClearCommand.MESSAGE_USAGE));
        }

        // keywords delimited by whitespace
        final String[] keywords = matcher.group("keywords").split("\\s+");
        final Set<String> keywordSet = new HashSet<>(Arrays.asList(keywords));
        return new ClearCommand(keywordSet);
    }

}
```
###### /java/seedu/task/logic/parser/MarkCommandParser.java
``` java
/**
 * Parses input arguments and creates a new MarkCommand object
 */
public class MarkCommandParser {

    /**
     * Parses the given {@code String} of arguments in the context of the MarkCommand
     * and returns an MarkCommand object for execution.
     */
    public Command parse(String args) {
        assert args != null;
        ArgumentTokenizer argsTokenizer = new ArgumentTokenizer();
        argsTokenizer.tokenize(args);
        List<Optional<String>> preambleFields = ParserUtil.splitPreamble(argsTokenizer.getPreamble().orElse(""), 2);

        Optional<Integer> index = preambleFields.get(0).flatMap(ParserUtil::parseIndex);
        if (!index.isPresent()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, MarkCommand.MESSAGE_USAGE));
        }

        return new MarkCommand(index.get());
    }
}
```
###### /java/seedu/task/logic/commands/RedoCommand.java
``` java
/**
 * Command that redoes changes caused by the last command.
 */
public class RedoCommand extends Command {

    public static final String COMMAND_WORD = "redo";
    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Undoes the changes made by the last command.\n";
    public static final String REDO_SUCCESS = "Redo!";
    public static final String REDO_FAILURE = "Nothing to redo!";

    public RedoCommand() {
    }

    @Override
    public CommandResult execute() throws CommandException {
        boolean result = model.redoLastModification();

        return new CommandResult(result ? REDO_SUCCESS : REDO_FAILURE);
    }

}
```
###### /java/seedu/task/logic/commands/AddCommand.java
``` java
    /**
     * Constructs a an AddCommand
     * @param keywords composing the task to add.
     */
    public AddCommand(List<String> keywords) throws IllegalValueException {

        Optional<Name> name = getName(keywords);
        Optional<Group> group = getGroup(keywords);
        Optional<StartDate> start = getStartDate(keywords);
        Optional<EndDate> end = getEndDate(keywords);

        if (!name.isPresent()) {
            throw new IllegalValueException(MESSAGE_NONAME);
        }

        if (!group.isPresent()) {
            group = Optional.of(new Group(Group.GROUP_ID_HIDDEN));
        }

        if (start.isPresent() && !end.isPresent()) {
            throw new IllegalValueException(MESSAGE_ILLEGAL_TIME_PARAMS);
        }

        if (start.isPresent() && end.isPresent()
                && end.get().getTime().compareTo(start.get().getTime()) < 0) {
            throw new IllegalValueException(MESSAGE_ILLEGAL_TIME_INTERVAL);
        }

        try {
            toAdd = Task.factory(
                    name.get(),
                    group.get(),
                    start.isPresent() ? start.get() : null,
                    end.isPresent() ? end.get() : null,
                    UniqueTagList.build(Tag.TAG_INCOMPLETE));
        } catch (IllegalValueException e) {
            //TODO error
        }
    }
```
###### /java/seedu/task/logic/commands/AddCommand.java
``` java
    /**
     * Extracts name from keywords
     * @param keywords to search
     * @return name if found
     */
    private static Optional<Name> getName(List<String> keywords) {
        String inner = StringUtil.extract(keywords, 0, SPECIAL_KEYWORDS);
        if (!inner.isEmpty()) {
            try {
                return Optional.of(new Name(inner));
            } catch (IllegalValueException e) {
            }
        }
        return Optional.empty();
    }
```
###### /java/seedu/task/logic/commands/ClearCommand.java
``` java
/**
 * Clears the task manager.
 */
public class ClearCommand extends Command {

    public static final String COMMAND_WORD = "clear";

    public static final String KEYWORD_ALL = "all";
    public static final String KEYWORD_COMPLETE = Tag.TAG_COMPLETE;
    public static final String KEYWORD_PASSED = "passed";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Clears all tasks, "
            + "or only completed tasts if the " + KEYWORD_COMPLETE + " keyword is specified.\n"
            + "Parameters: [keyword]\n"
            + "Keywords : "
            + KEYWORD_ALL
            + ", "
            + KEYWORD_COMPLETE
            + ", "
            + KEYWORD_PASSED
            + "\n"
            + "Example: " + COMMAND_WORD + " completed";

    public static final String MESSAGE_SUCCESS_ALL = "All tasks have been cleared!";
    public static final String MESSAGE_SUCCESS_COMPLETE = "All competed tasks have been cleared!";
    public static final String MESSAGE_SUCCESS_PASSED = "All passed tasks have been cleared!";
    public static final String MESSAGE_FAILURE = "Clear command not given any keywords!\n" + MESSAGE_USAGE;

    private Set<String> keywords;

    public ClearCommand(Set<String> keywords) {
        this.keywords = keywords;
    }

    @Override
    public CommandResult execute() {
        assert model != null;

        if (keywords.contains(KEYWORD_ALL)) {

            model.resetData(new YTomorrow());

            return new CommandResult(MESSAGE_SUCCESS_ALL);
        }

        if (keywords.contains(KEYWORD_COMPLETE)) {

            List<ReadOnlyTask> filtered = new ArrayList<ReadOnlyTask>();
            for (ReadOnlyTask task : model.getTaskManager().getTaskList()) {
                try {
                    if (!task.getTags().contains(new Tag(Tag.TAG_COMPLETE))) {
                        filtered.add(task);
                    }
                } catch (IllegalValueException e) {
                    e.printStackTrace();
                }
            }
            YTomorrow filteredYTomorrow = new YTomorrow();
            try {
                filteredYTomorrow.setTasks(filtered);
            } catch (DuplicateTaskException e) {
                e.printStackTrace();
            }
            model.resetData(filteredYTomorrow);

            return new CommandResult(MESSAGE_SUCCESS_COMPLETE);
        }

        if (keywords.contains(KEYWORD_PASSED)) {

            List<ReadOnlyTask> filtered = new ArrayList<ReadOnlyTask>();
            for (ReadOnlyTask task : model.getTaskManager().getTaskList()) {
                if (!task.hasPassed()) {
                    filtered.add(task);
                }
            }
            YTomorrow filteredYTomorrow = new YTomorrow();
            try {
                filteredYTomorrow.setTasks(filtered);
            } catch (DuplicateTaskException e) {
                e.printStackTrace();
            }
            model.resetData(filteredYTomorrow);

            return new CommandResult(MESSAGE_SUCCESS_PASSED);
        }

        return new CommandResult(MESSAGE_FAILURE);
    }
}
```
###### /java/seedu/task/logic/commands/MarkCommand.java
``` java
/**
 * Command that marks a task as complete.
 */
public class MarkCommand extends Command {

    public static final String COMMAND_WORD = "mark";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Marks as complete the task identified "
            + "by the index number used in the last task listing.\n"
            + "Parameters: INDEX (must be a positive integer)\n"
            + "Example: " + COMMAND_WORD + " 1";

    public static final String MESSAGE_MARK_TASK_SUCCESS = "Marked task complete: %1$s";
    public static final String MESSAGE_DUPLICATE_TASK = "This task is already complete.";

    private final int filteredTaskListIndex;

    /**
     * @param filteredTaskListIndex the index of the task in the filtered task list to edit
     * @param editTaskDescriptor details to edit the task with
     */
    public MarkCommand(int filteredTaskListIndex) {
        assert filteredTaskListIndex > 0;

        // converts filteredTaskListIndex from one-based to zero-based.
        this.filteredTaskListIndex = filteredTaskListIndex - 1;
    }

    @Override
    public CommandResult execute() throws CommandException {
        List<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

        if (filteredTaskListIndex >= lastShownList.size()) {
            throw new CommandException(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        ReadOnlyTask taskToEdit = lastShownList.get(filteredTaskListIndex);
        ReadOnlyTask editedTask = createMarkedTask(taskToEdit);

        try {
            model.updateTask(filteredTaskListIndex, editedTask);
        } catch (UniqueTaskList.DuplicateTaskException dpe) {
            throw new CommandException(MESSAGE_DUPLICATE_TASK);
        }
        model.updateFilteredListToShowAll();
        return new CommandResult(String.format(MESSAGE_MARK_TASK_SUCCESS, taskToEdit));
    }

```
###### /java/seedu/task/commons/core/GuiSettings.java
``` java
    /**
     * Gets the stylesheet stored in GuiSettings
     * @return String path to stylesheet
     */
    public String getStyleSheet() {
        return styleSheet;
    }

    /**
     * Gets the last loaded Y Tomorrow task database
     * @return Path to last loaded task database
     */
    public String getLastLoadedYTomorrow() {
        return lastLoadedYTomorrow;
    }

    /**
     * Stores the stylesheet path
     * @param path to store
     */
    public void setStyleSheet(String path) {
        styleSheet = path;
    }

    /**
     * Store the YTomorrow task database path
     * @param path to store
     */
    public void setLastLoadedYTomorrow(String path) {
        lastLoadedYTomorrow = path;
    }
```
###### /java/seedu/task/commons/events/storage/ImportRequestEvent.java
``` java
/**
* Represents a request to retrieve the file at the stored path.
*/
public class ImportRequestEvent extends BaseEvent {

    private File target;

    public ImportRequestEvent(File target) {
        this.target = target;
    }

    /**
     * Get file path to import from
     * @return file path to import from
     */
    public File getTargetFile() {
        return target;
    }

    @Override
    public String toString() {
        return "Imported YTomorrow: " + target.toString();
    }
}
```
###### /java/seedu/task/commons/events/storage/ImportResultAvailableEvent.java
``` java
/**
 * Indicates that a new result is available.
 */
public class ImportResultAvailableEvent extends BaseEvent {

    private final Optional<ReadOnlyTaskManager> imported;

    public ImportResultAvailableEvent(Optional<ReadOnlyTaskManager> imported) {
        this.imported = imported;
    }

    /**
     * Get the imported YTomorrow task database
     * @return Imported YTomorrow task database
     */
    public Optional<ReadOnlyTaskManager> getImported() {
        return imported;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

}
```
###### /java/seedu/task/commons/events/storage/ExportRequestEvent.java
``` java
/**
 * Represents a request to export the stored YTomorrow task file.
 */
public class ExportRequestEvent extends BaseEvent {

    private ReadOnlyTaskManager toExport;
    private File target;

    public ExportRequestEvent(ReadOnlyTaskManager toExport, File target) {
        this.toExport = toExport;
        this.target = target;
    }

    /**
     * Get the YTomorrow task database to export
     * @return YTomorrow task database to export
     */
    public ReadOnlyTaskManager getYTomorrowToExport() {
        return toExport;
    }

    /**
     * Gets the file path to export to
     * @return File path to export to
     */
    public File getTargetFile() {
        return target;
    }

    @Override
    public String toString() {
        return "Exported YTomorrow: " + target.toString();
    }

}
```
###### /java/seedu/task/commons/events/storage/TargetFileRequestEvent.java
``` java
/**
* Represents a request to save changes to the stored path.
*/
public class TargetFileRequestEvent extends BaseEvent {

    File target;
    UserPrefs prefs;

    public TargetFileRequestEvent(File target, UserPrefs prefs) {
        this.target = target;
        this.prefs = prefs;
    }

    /**
     * Get file path to redirect all further edits to
     * @return File path to redirect all further edits to
     */
    public File getTargetFile() {
        return target;
    }

    /**
     * Get user preferences to modify with target file path
     * @return User preferences to modify
     */
    public UserPrefs getUserPrefs() {
        return prefs;
    }

    @Override
    public String toString() {
        return "Targeting new YTomorrow file: " + target.toString();
    }

}
```
###### /java/seedu/task/commons/events/ui/ShowThemeWindowRequestEvent.java
``` java
/**
 * An event indicating a request to view the Theme Window.
 */
public class ShowThemeWindowRequestEvent extends BaseEvent {

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

}
```
###### /java/seedu/task/commons/util/DateUtil.java
``` java
/**
 * Class of date-related methods
 */
public class DateUtil {

    /**
     * Parses string and attempts to transform it into a date
     * @param Natural-language string to interpret date from
     * @return java.util.Date created from passed string
     * @throws IllegalValueException
     */
    public static Date parse(String rawDate) throws IllegalValueException {
        try {
            Parser parser = new Parser();
            List<DateGroup> groups = parser.parse(rawDate);
            Date date = groups.get(0).getDates().get(0);
            return date;
        } catch (IndexOutOfBoundsException e) {
            throw new IllegalValueException(seedu.task.model.task.Date.MESSAGE_DATE_CONSTRAINTS);
        }
    }

    /**
     * Returns new date past given date by given days
     * @param Date to start at
     * @param Days to add
     * @return New date past given date by given days
     */
    public static Date add(Date date, int days) {
        Calendar c = Calendar.getInstance();
        c.setTime(date);
        c.add(Calendar.DATE, days);
        return c.getTime();
    }

```
###### /java/seedu/task/commons/util/CollectionUtil.java
``` java
    /**
     * Returns first occurrence of the given type in the array.
     * @param Collection to search.
     * @param Type to find.
     * @return First object of given type, or null if not found.
     */
    public static <T> T firstOf(Object[] items, Class<T> type) {
        for (Object el : items) {
            if (type.isInstance(el)) {
                return type.cast(el);
            }
        }
        return null;
    }

    /**
     * Returns a random element from the given array
     * @param Array to retrieve from
     * @param Random object to use
     * @return Randomly-chosen element from array
     */
    public static <T> T getRandom(T[] arr, Random r) {
        return arr[r.nextInt(arr.length)];
    }

    /**
     * Finds the first in the list of the set of last indices of any in the searched list
     * @param List to search
     * @param Elements to find last indices of
     * @return First in the list of the set of last indices of any in the searched list
     */
    public static <T> int firstLastIndexOfAny(List<T> list, List<T> any) {
        int i = list.size();
        for (T a : any) {
            int t = list.lastIndexOf(a);
            if (t != -1 && t < i) {
                i = t;
            }
        }
        return i;
    }
```
###### /java/seedu/task/commons/util/FileUtil.java
``` java
    /**
     * Creates a localized window to create a file for saving.
     * @param Window title
     * @param File extension filters
     * @return Chosen file
     */
    public static File promptSaveFileDialog(String title, Stage stage, ExtensionFilter ...extensionFilters) {
        FileChooser prompt =  getFileChooser(title, extensionFilters);
        File saved = prompt.showSaveDialog(stage);
        if (!saved.getName().contains(".")) {
            saved = new File(saved.getAbsolutePath()
                  + prompt.getSelectedExtensionFilter().getExtensions().get(0).substring(1));
        }
        return saved;
    }

    /**
     * Creates a localized window to select a file for loading.
     * @param Window title
     * @param File extension filters
     * @return Chosen file
     */
    public static File promptOpenFileDialog(String title, Stage stage, ExtensionFilter ...extensionFilters) {
        return getFileChooser(title, extensionFilters).showOpenDialog(stage);
    }

    /**
     * Returns a new file chooser prompt
     * @param Title of prompt
     * @param Extension filters to allow for writing/reading
     * @return New file chooser prompt
     */
    private static FileChooser getFileChooser(String title, ExtensionFilter ...extensionFilters) {
        FileChooser fileChooser = new FileChooser();

        fileChooser.setTitle(title);
        fileChooser.getExtensionFilters().addAll(extensionFilters);

        return fileChooser;
    }
}
```
###### /java/seedu/task/commons/util/StringUtil.java
``` java
    /**
     * Extracts space-concatenated string until end or the first of the last instances of the passed haltAt keywords
     * @param Keywords to parse
     * @param Index to start at
     * @param Keywords to stop at once the first of the set of last instances is met
     * @return Concatenated string of all keywords between start and index specified by the keywords parameter
     */
    public static String extract(List<String> keywords, int start, List<String> haltAt) {
        return StringUtil.concat(keywords.subList(
                start,
                start + CollectionUtil.firstLastIndexOfAny(keywords.subList(start, keywords.size()), haltAt)));
    }

    /**
     * Concatenates Strings with the space character
     * @param Strings to concatenate
     * @return Concatenated String
     */
    public static String concat(List<String> strs) {
        return StringUtil.concat(strs, " ");
    }

    /**
     * Concatenates Strings with the specified character
     * @param Strings to concatenate
     * @param String to repeat between strs
     * @return Concatenated String
     */
    public static String concat(List<String> strs, String between) {
        String cat = "";
        for (int i = 0; i < strs.size(); i++) {
            if (i == 0) {
                cat = strs.get(i);
                continue;
            }

            cat += between + strs.get(i);
        }
        return cat;
    }
```
###### /java/seedu/task/model/task/DeadlineTask.java
``` java
/**
 * Represents a Deadline Task in the YTomorrow.
 */
public class DeadlineTask extends Task {
    public DeadlineTask(Name name, EndDate end, Group group, UniqueTagList tags) {
        super(name, null, end, group, tags);
    }
}
```
###### /java/seedu/task/model/task/Task.java
``` java
    /**
     * Factory method to build a Task or Task-inheriting class from a given unordered array of properties.
     * @param Properties to build Task with
     * @return New Task with given properties
     * @throws IllegalValueException Insufficient/invalid properties given
     */
    public static Task factory(Object ...properties) throws IllegalValueException {
        Name name = CollectionUtil.firstOf(properties, Name.class);
        Group group = CollectionUtil.firstOf(properties, Group.class);
        UniqueTagList tags = CollectionUtil.firstOf(properties, UniqueTagList.class);
        StartDate start = CollectionUtil.firstOf(properties, StartDate.class);
        EndDate end = CollectionUtil.firstOf(properties, EndDate.class);

        if (CollectionUtil.isAnyNull(name, group, tags)) {
            throw new IllegalValueException("Task Factory: new task requires a name, group, and tag list");
        }

        if (start != null && end != null) {
            return new Task(name, start, end, group, tags);
        } else if (start == null && end != null) {
            return new DeadlineTask(name, end, group, tags);
        } else if (start == null && end == null) {
            return new FloatingTask(name, group, tags);
        }

        return null;
    }


    @Override
    public boolean hasPassed() {
        return getEndTime().before(new java.util.Date());
    }

}
```
###### /java/seedu/task/model/task/EndDate.java
``` java
/**
* Represents an End Date in the YTomorrow.
*/
public class EndDate extends Date {
    public EndDate(String date) throws IllegalValueException {
        super(date);

        if (date == null) {
            inputValue = null;
            value = new java.util.Date(Long.MAX_VALUE);
        }
    }
}
```
###### /java/seedu/task/model/task/FloatingTask.java
``` java
/**
 * Represents a Floating Task in the YTommorow.
 */
public class FloatingTask extends Task {
    public FloatingTask(Name name, Group group, UniqueTagList tags) {
        super(name, null, null, group, tags);
    }
}
```
###### /java/seedu/task/model/task/ReadOnlyTask.java
``` java
    /**
     * @return Whether the task end date has passed the time of calling.
     */
    boolean hasPassed();
    //@author

    java.util.Date getEndTime();

    java.util.Date getStartTime();

}
```
###### /java/seedu/task/model/task/StartDate.java
``` java
/**
 * Represents a Start Date in the YTomorrow.
 */
public class StartDate extends Date {
    public StartDate(String date) throws IllegalValueException {
        super(date);

        if (date == null) {
            inputValue = null;
            value = new java.util.Date(Long.MAX_VALUE);
        }
    }
}
```
###### /java/seedu/task/model/History.java
``` java
/**
 * Data structure for undo/redo history
 * @param <T> State type to save
 */
public class History<T> {

    private Node<T> current = null;

    /**
     * Moves current state back one push.
     * @return State after undo
     */
    public T undo() {
        if (current == null) {
            return null;
        }

        Node<T> prev = current.getPrevious();
        if (prev == null) {
            return null;
        } else {
            current = prev;
            return prev.getElement();
        }
    }

    /**
     * Moves current state forward one push.
     * @return State after redo
     */
    public T redo() {
        if (current == null) {
            return null;
        }

        Node<T> next = current.getNext();
        if (next == null) {
            return null;
        } else {
            current = next;
            return next.getElement();
        }
    }

    /**
     * @return Current state
     */
    public T at() {
        if (current != null) {
            return current.getElement();
        } else {
            return null;
        }
    }

    /**
     * Adds value after current state.  Deletes the previous next value.
     * @param Value to add as next
     */
    public void push(T next) {
        Node<T> nextNode = new Node<T>(next);

        if (current != null) {
            nextNode.setPrevious(current);
            current.setNext(nextNode);
        }

        current = nextNode;
    }

    /**
     * @return Total number of saved states
     */
    public int size() {
        return 1 + sizePrev(current) + sizeNext(current);
    }

    /**
     * @param Source node to count from
     * @return Number of nodes before source node
     */
    private int sizePrev(Node<T> source) {
        return source.getPrevious() == null ? 0 : 1 + sizePrev(source.getPrevious());
    }

    /**
     * @param Source node to count from
     * @return Number of nodes after source node
     */
    private int sizeNext(Node<T> source) {
        return source.getNext() == null ? 0 : 1 + sizePrev(source.getNext());
    }

    /**
     * Doubly-linked-list node
     * @param <T> Element type to store
     */
    private class Node<T> {

        private T element;

        private Node<T> prev = null;
        private Node<T> next = null;

        public Node(T element) {
            this.element = element;
        }

        /**
         * @return Stored value
         */
        public T getElement() {
            return element;
        }

        /**
         * @return Previous node
         */
        public Node<T> getPrevious() {
            return prev;
        }

        /**
         * @return Next node
         */
        public Node<T> getNext() {
            return next;
        }

        /**
         * Set next node
         * @param Node to insert
         */
        public void setNext(Node<T> next) {
            this.next = next;
        }

        /**
         * Set previous node
         * @param Node to insert
         */
        public void setPrevious(Node<T> prev) {
            this.prev = prev;
        }

    }
}
```
###### /java/seedu/task/model/ModelManager.java
``` java
    @Override
    public boolean undoLastModification() {
        ReadOnlyTaskManager undone = history.undo();
        if (undone != null) {
            taskManager.resetData(undone);
```
###### /java/seedu/task/model/Model.java
``` java

    /** Undoes the last modification made to the TaskManager. Returns if there is anything to undo. */
    boolean undoLastModification();

    /** Redoes the last modification made to the TaskManager. Returns if there is anything to redo. */
    boolean redoLastModification();

    /** Adds the current TaskManager state to the undo/redo history */
    void addToHistory(ReadOnlyTaskManager state);

    /** Adds entries from the given YTomorrow to the current YTomorrow and updates equivalent entries. */
    void mergeYTomorrow(ReadOnlyTaskManager add);
}
```
###### /java/seedu/task/model/util/TaskNameGenerator.java
``` java
/**
 * Builder for randomly-generating task names
 */
public class TaskNameGenerator {
    private static final String[] ACTIONS = {
        "Walk",
        "Study",
        "Talk",
        "Chat",
        "Take photos",
        "Eat",
        "Parkour",
        "Makan",
        "Cram study",
        "Take test",
        "Meet",
        "Exercise",
        "Shop",
        "Play Minecraft",
        "Figure out travel plans",
        "Draw art",
        "Do calligraphy",
        "Play videogames",
        "Hike",
    };

    private static final String[] NAMES = {
        "George P. Burdell",
        "Tony",
        "Malik",
        "Cheuk Ting",
        "Ali",
        "Rabab",
        "Alia",
        "Mohsin",
        "Ellie",
        "Sarah",
        "Satoshi",
        "Mars",
        "Elon Musk",
        "Jaden",
        "Chris",
        "Cristina",
        "Husain",
        "class",
        "project group",
        "fam",
        "Layla",
        "Jake",
        "John",
        "Jon",
        "Allison",
        "Bill",
        "Robert",
        "Mr. Anderson",
        "Hannah",
        "Gabe",
        "squad",
    };

    private static final String[] PLACES = {
        "Woodys",
        "Tech Tower",
        "MBS",
        "PGP",
        "Techno Edge",
        "japanese restaurant",
        "hotpot restaurant",
        "Central Library",
        "Yishun",
        "Punggol",
        "Sentosa",
        "Changi Airport",
        "golf course",
        "hawker centre",
        "NUH",
        "NUS",
        "Pasir Panjang Rd.",
        "Raffles Place",
    };

    private static Random r;

    private TaskNameGenerator previous;
    private String state;

    private TaskNameGenerator(TaskNameGenerator previous, String state) {
        this.previous = previous;
        this.state = state;
    }

    @Override
    public String toString() {
        return (previous != null ? previous.toString() + " " : "") + state;
    }

    /**
     * @return Set a random action
     * @param Random object to use
     */
    public static TaskNameGenerator doAction(Random r) {
        return doAction(r, CollectionUtil.getRandom(ACTIONS, r));
    }

    /**
     * @return Set a given action
     * @param Random object to use
     */
    public static TaskNameGenerator doAction(Random r, String action) {
        TaskNameGenerator.r = r;
        return new TaskNameGenerator(null, action);
    }

    /**
     * @return Set a random person to do with
     */
    public TaskNameGenerator with() {
        return with(CollectionUtil.getRandom(NAMES, r));
    }

    /**
     * @return Set a given person to do with
     */
    public TaskNameGenerator with(String name) {
        return new TaskNameGenerator(this, "with " + name);
    }

    /**
     * @return Set a random place to do in
     */
    public TaskNameGenerator in() {
        return in(CollectionUtil.getRandom(PLACES, r));
    }

    /**
     * @return Set a given place to do in
     */
    public TaskNameGenerator in(String place) {
        return new TaskNameGenerator(this, "in " + place);
    }

    /**
     * @return Randomly unset the previous call (frequency: 0.5)
     */
    public TaskNameGenerator maybe() {
        return maybe(0.5f);
    }

    /**
     * @return Randomly unset the previous call with given frequency
     */
    public TaskNameGenerator maybe(float chance) {
        if (r.nextFloat() > chance) {
            if (previous == null) {
                state = "";
            } else {
                return previous;
            }
        }
        return this;
    }

}
```
###### /java/seedu/task/model/util/TaskGroupGenerator.java
``` java
/**
 * Random generator for Task Group strings
 */
public class TaskGroupGenerator {

    private static final String[] GROUPS = {
        "Vacation",
        "School",
        "Family",
        "Plans",
        "Hobbies",
        "ES",
    };

    /**
     * @param Random to use
     * @return Randomly-chosen group
     */
    public static String getGroup(Random r) {
        return CollectionUtil.getRandom(GROUPS, r);
    }

}
```
###### /java/seedu/task/model/util/SampleDataUtil.java
``` java
public class SampleDataUtil {

    private static final int SAMPLE_SIZE = 50;

    Random r;

    /**
     * @param Number of tasks to generate
     * @return Array of randonly-generated tasks
     */
    public static ReadOnlyTask[] getSampleTasks(int n) {
        Set<Task> generated = new HashSet<Task>();
        for (int i = 0; i < n; i++) {
            if (!generated.add(generateRandomTask())) {
                i--;
            }
        }
        return generated.toArray(new Task[n]);
    }

    /**
     * @return a randomly-generated task
     * @throws IllegalValueException
     */
    private static Task generateRandomTask() {
        Random r = new Random();
        boolean addStartDate = r.nextBoolean();
        boolean addEndDate = r.nextBoolean();

        try {

            return Task.factory(
                    new Name(TaskNameGenerator.doAction(r).with().maybe(0.75f).in().maybe(0.75f).toString()),
                    addStartDate && addEndDate ?  TaskDateGenerator.getStartDate(r) : null,
                    addEndDate ? TaskDateGenerator.getEndDate(r) : null,
                    new Group(TaskGroupGenerator.getGroup(r)),
                    UniqueTagList.build(r.nextBoolean() ? Tag.TAG_COMPLETE : Tag.TAG_INCOMPLETE));

        } catch (IllegalValueException e) {
            return generateRandomTask();
        }
    }
```
###### /java/seedu/task/model/util/TaskDateGenerator.java
``` java
/**
 * Random generator for Task start and end dates
 */
public class TaskDateGenerator {

    private static final int MAX_DAYS_TO_ADD = 255;

    private static final String[] STARTDATES = {
        "today",
        "tomorrow",
        "yesterday",
        "day after tomorrow",
        "day before yesterday",
        "next year",
        "last year",
        "this year",
        "april 1",
        "may 28",
        "monday",
        "tuesday",
        "wednesday",
        "thursday",
        "friday",
        "saturday",
        "sunday",
        "next monday",
        "next tuesday",
        "next wednesday",
        "next thursday",
        "next friday",
        "next saturday",
        "next sunday",
        "last monday",
        "last tuesday",
        "last wednesday",
        "last thursday",
        "last friday",
        "last saturday",
        "last sunday",
        "00-00-0000",
        "00-00-1000",
        "12-12-1234",
        "15-05-1977",
        "22-09-2024",
        "05-02-2199",
        "06.04.12017",
    };

    private static Random r;

    private static StartDate lastStartDate;

    /**
     * @param Random to use
     * @return Randomly-generated start date
     */
    public static StartDate getStartDate(Random r) {
        TaskDateGenerator.r = r;

        try {
            lastStartDate = new StartDate(CollectionUtil.getRandom(STARTDATES, r));
        } catch (IllegalValueException e) {
            return getStartDate(r);
        }

        return lastStartDate;
    }

    /**
     * @param Random to use
     * @return Randomly generated end date
     */
    public static EndDate getEndDate(Random r) {
        if (lastStartDate == null) {
            getStartDate(r);
        }

        try {
            return new EndDate(r.nextInt(MAX_DAYS_TO_ADD + 1) + " days after " + lastStartDate.toString());
        } catch (IllegalValueException e) {
            getStartDate(r);
            return getEndDate(r);
        }
    }
}
```
###### /java/seedu/task/model/tag/UniqueTagList.java
``` java
    /**
     * Creates copy of this tag list containing all tags except those in the passed tag list
     */
    public UniqueTagList except(UniqueTagList except) {
        UniqueTagList remaining = new UniqueTagList();

        for (Tag tag : except) {
            if (except.contains(tag)) continue;

            try {
                remaining.add(new Tag(tag.tagName));
            } catch (DuplicateTagException e) {
                e.printStackTrace();
            } catch (IllegalValueException e) {
                e.printStackTrace();
            }
        }

        return remaining;
    }
```
###### /java/seedu/task/model/tag/UniqueTagList.java
``` java
    /**
     * Constructs a tag list from a variadic parameter list of strings
     */
    public static UniqueTagList build(String ... tagNames) {
        UniqueTagList tags = new UniqueTagList();

        try {
            for (String tagName : tagNames) {
                tags.add(new Tag(tagName));
            }
        } catch (DuplicateTagException e) {
            e.printStackTrace();
        } catch (IllegalValueException e) {
            e.printStackTrace();
        }

        return tags;
    }
```
###### /java/seedu/task/storage/TaskManagerStorage.java
``` java
    /** Sets the Address Book file path */
    void setAddressBookFilePath(String path);
```
###### /java/seedu/task/storage/XmlAddressBookStorage.java
``` java
    @Override
    public void setAddressBookFilePath(String path) {
        this.filePath = path;
    }
```
###### /java/seedu/task/storage/StorageManager.java
``` java
    @Override
    @Subscribe
    public void handleExportRequestEvent(ExportRequestEvent ere) {
        try {
            saveAddressBook(ere.getYTomorrowToExport(), ere.getTargetFile().getPath());
        } catch (IOException e) {
            raise(new DataSavingExceptionEvent(e));
        }
    }

    @Override
    @Subscribe
    public void handleLoadRequestEvent(LoadRequestEvent ire) {
        Optional<ReadOnlyTaskManager> loaded = null;

        try {
            loaded = readTaskManager(ire.getTargetFile().getPath());
        } catch (DataConversionException | IOException e) {
        }

        raise(new LoadResultAvailableEvent(loaded, ire.getTargetFile()));
    }

    @Override
    @Subscribe
    public void handleImportRequestEvent(ImportRequestEvent ire) {
        Optional<ReadOnlyTaskManager> loaded = null;

        try {
            loaded = readTaskManager(ire.getTargetFile().getPath());
        } catch (DataConversionException | IOException e) {
        }

        raise(new ImportResultAvailableEvent(loaded));
    }

    @Override
    @Subscribe
    public void handleTargetFileRequestEvent(TargetFileRequestEvent tfre) {
        addressBookStorage.setAddressBookFilePath(tfre.getTargetFile().getPath());
        tfre.getUserPrefs().getGuiSettings().setLastLoadedYTomorrow(tfre.getTargetFile().getPath());
    }

    @Override
    public void setAddressBookFilePath(String path) {
        addressBookStorage.setAddressBookFilePath(path);
    }
```
###### /java/seedu/task/storage/Storage.java
``` java
    /**
     * Saves the current version of the Address Book to the hard disk at a specified path.
     *   Creates the data file if it is missing.
     * Raises {@link DataSavingExceptionEvent} if there was an error during saving.
     */
    void handleExportRequestEvent(ExportRequestEvent ere);

    /**
     * Retrieves an Address Book at the specified path.
     */
    void handleImportRequestEvent(ImportRequestEvent ire);

    /**
     * Sets the file to which Address Book saving is done.
     */
    void handleTargetFileRequestEvent(TargetFileRequestEvent tfre);

    void handleLoadRequestEvent(LoadRequestEvent ire);
```
###### /java/seedu/task/ui/CommandBox.java
``` java
    /**
     * Sets hot-keys for this window:
     * Up arrow - write last command to command box
     * Down arrow - clears command box
     */
    private void setAccelerators() {
        commandTextField.setOnKeyPressed(keyEvent -> {
            switch (keyEvent.getCode()) {
            case UP:
                handleLast();
                break;
            case DOWN:
                handleClear();
                break;
            default:
            }
        });
    }
```
###### /java/seedu/task/ui/CommandBox.java
``` java
    /**
     * Writes the last command string to the command box
     */
    private void handleLast() {
        if (lastCommand != null) {
            commandTextField.setText(lastCommand);
        }
    }

    /**
     * Clears the command box
     */
    private void handleClear() {
        commandTextField.clear();
    }
```
###### /java/seedu/task/ui/ThemeWindow.java
``` java
/**
 * The Theme Window. Provides a list of css files to load in order to change the application theme.
 * Under the list, a file browsing entry allows usage of an external css file.
 * The chosen configuration option is saved.
 */
public class ThemeWindow extends Window {

    protected static final String ICON = "/images/theme_icon.png";
    protected static final String FXML = "ThemeWindow.fxml";
    private static final String TITLE = "Theme Manager";

    @FXML
    private AnchorPane themeManagerPlaceholder;

    @FXML
    private Parent fxmlToApply;

    @FXML
    public ListView<String> themeListView;

    public ThemeWindow(Parent fxmlToApply) {
        super(FXML);

        setTitle(TITLE);
        FxViewUtil.setStageIcon(stage, ICON);
        this.fxmlToApply = fxmlToApply;

        setConnections();
        setEventHandlerForSelectionChangeEvent();
        setAccelerators();
    }

    /**
     * Sets hot-keys for this window:
     * Enter - Closes window
     */
    private void setAccelerators() {
        themeListView.setOnKeyPressed(new EventHandler<KeyEvent>() {

            @Override
            public void handle(final KeyEvent keyEvent) {
                if (keyEvent.getCode() == KeyCode.ENTER) {
                    handleExit();
                    keyEvent.consume();
                }
            }
        });
    }

    /**
     * Closes window
     */
    @FXML
    public void handleExit() {
        getStage().close();
    }

    /**
     * Connects the list to the list of allowable themes
     */
    private void setConnections() {
        themeListView.setItems(Theme.THEMES);
    }

    /**
     * Sets handler for changing the selected theme for MainWindow on new selection
     */
    private void setEventHandlerForSelectionChangeEvent() {
        themeListView.getSelectionModel().selectedItemProperty()
               .addListener((observable, oldValue, newValue) -> {
                   if (newValue != null) {
                       LOGGER.fine("Theme has changed to : '" + newValue + "'");
                       Theme.changeTheme(fxmlToApply, newValue);
                   }
               });
    }
}
```
###### /java/seedu/task/ui/MainWindow.java
``` java
    /**
     * Handle a JavaFX save button request.
     * Initiates a saving sequence.
     */
    @FXML
    public void handleSave() {
        File selected = FileUtil.promptSaveFileDialog("Save and Use YTomorrow File", getStage(),
                new ExtensionFilter("YTomorrow XML Files", "*.xml"));

        if (selected != null) {
            ReadOnlyTaskManager current = logic.getYTomorrow();
            raise(new ExportRequestEvent(current, selected));
            raise(new TargetFileRequestEvent(selected, prefs));
        }
    }

    /**
     * Handle a JavaFX load button request.
     * Initiates a loading sequence.
     */
    @FXML
    public void handleLoad() {
        File selected = FileUtil.promptOpenFileDialog("Load and Use YTomorrow File", getStage(),
                new ExtensionFilter("YTomorrow XML Files", "*.xml"));

        if (selected != null) {
            raise(new LoadRequestEvent(selected));
        }
    }

    /**
     * Handle a JavaFX export button request.
     * Initiates an export sequence.
     */
    @FXML
    public void handleExport() {
        File selected = FileUtil.promptSaveFileDialog("Export YTomorrow File", getStage(),
                new ExtensionFilter("YTomorrow XML Files", "*.xml"));

        if (selected != null) {
            ReadOnlyTaskManager current = logic.getYTomorrow();
            raise(new ExportRequestEvent(current, selected));
        }
    }

    /**
     * Handle a JavaFX import button request.
     * Initiates an import sequence
     */
    @FXML
    public void handleImport() {
        File selected = FileUtil.promptOpenFileDialog("Import YTomorrow File", getStage(),
                new ExtensionFilter("YTomorrow XML Files", "*.xml"));

        if (selected != null) {
            raise(new ImportRequestEvent(selected));
        }
    }

    /**
     * Handle a JavaFX theme manager button request.
     * Opens a ThemeWindow
    */
    @FXML
    public void handleTheme() {
        ThemeWindow themeWindow = new ThemeWindow(getRoot());
        themeWindow.show();
    }
```
###### /java/seedu/task/ui/HelpWindow.java
``` java
    private static final String HELP_HTML =
            "http://CS2103JAN2017-F11-B3.github.io/main/util/offdoc.html"
            + "?mdfile=https://raw.githubusercontent.com/"
            + "CS2103JAN2017-F11-B3/main/master/docs/UserGuide.md";
```
###### /java/seedu/task/ui/Theme.java
``` java
/**
 * Class for managing available themes and theme-related methods
 */
public class Theme {

    public static final String STYLESHEET_EXTENSION = ".css";
    public static final String THEME_FILE_FOLDER = "/themes/";
    public static final String EXTENSIONS_STYLESHEET = "/view/Extensions.css";

    public static ObservableList<String> THEMES = FXCollections.observableArrayList(
            "BlandTheme",
            "DarkTheme",
            "BurntCyanTheme");
    public static final String DEFAULT_STYLESHEET = THEMES.get(2); // Burnt Cyan Theme

    /**
     *
     * @param Parent to set theme of.
     * @param Theme filename (without path or extension) to be applied.
     */
    public static void changeTheme(Parent root, String theme) {

        root.getStylesheets().clear();

        root.getStylesheets().add(MainApp.class.getResource(
               Theme.THEME_FILE_FOLDER
               + theme
               + Theme.STYLESHEET_EXTENSION)
               .toString());

        root.getStylesheets().add(MainApp.class.getResource(Theme.EXTENSIONS_STYLESHEET).toString());
    }
}
```
###### /java/seedu/task/ui/UiPart.java
``` java
    /**
     * Sets the css file used for the UIPart's FXML.
     */
    public void setStyleSheet(String path) {
        ((Parent) fxmlLoader.getRoot()).getStylesheets().add(path);
    }
```
###### /resources/view/Extensions.css
``` css
.error {
    -fx-background-color: #f08080;
}

.incomplete {
    -fx-border-color:  #ffcccc;
}

.complete {
    -fx-border-color: #69dead;
}

.tag-selector {
    -fx-border-width: 1;
    -fx-border-color: white;
    -fx-border-radius: 3;
    -fx-background-radius: 3;
}
```
###### /resources/view/ThemeWindow.fxml
``` fxml
<VBox xmlns="http://javafx.com/javafx/8" xmlns:fx="http://javafx.com/fxml/1">
	<stylesheets>
		<URL value="@Extensions.css" />
	</stylesheets>
	<children>
		<ListView fx:id="themeListView" VBox.vgrow="ALWAYS" />
		<Label text="Press ENTER to exit."/>
	</children>
</VBox>
```
###### /resources/themes/BurntCyanTheme.css
``` css
#cardPane {
    -fx-border-width: 2 2 2 24;
}

#cardPane #group {
	-fx-font-size: 8pt;
	-fx-font-family: "Segoe UI Light";
	-fx-hgap: 7;
    -fx-vgap: 3;
    -fx-text-fill: white;
    -fx-background-color: #383838;
    -fx-padding: 1 1 1 1;
    -fx-border-radius: 2;
    -fx-background-radius: 2;
}

#cardPane .label {
	-fx-font-size: 11pt;
	-fx-font-family: "Segoe UI Light";
}

#commandTypeLabel {
    -fx-font-size: 11px;
    -fx-text-fill: #F70D1A;
}

#filterField, #personListPanel, #personWebpage {
    -fx-effect: innershadow(gaussian, black, 10, 0, 0, 0);
}

#tags .label {
	-fx-hgap: 7;
    -fx-vgap: 3;
    -fx-text-fill: white;
    -fx-background-color: #383838;
    -fx-padding: 1 3 1 3;
    -fx-border-radius: 2;
    -fx-background-radius: 2;
    -fx-font-size: 11;
}
```
